/* automatically generated by rust-bindgen */


#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]


pub const BROTLI_SANITIZED: ::std::os::raw::c_int = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const BROTLI_TRUE: ::std::os::raw::c_int = 1;
pub const BROTLI_FALSE: ::std::os::raw::c_int = 0;
pub const BROTLI_MIN_WINDOW_BITS: ::std::os::raw::c_int = 10;
pub const BROTLI_MAX_WINDOW_BITS: ::std::os::raw::c_int = 24;
pub const BROTLI_LARGE_MAX_WINDOW_BITS: ::std::os::raw::c_int = 30;
pub const BROTLI_MIN_INPUT_BLOCK_BITS: ::std::os::raw::c_int = 16;
pub const BROTLI_MAX_INPUT_BLOCK_BITS: ::std::os::raw::c_int = 24;
pub const BROTLI_MIN_QUALITY: ::std::os::raw::c_int = 0;
pub const BROTLI_MAX_QUALITY: ::std::os::raw::c_int = 11;
pub const BROTLI_DEFAULT_QUALITY: ::std::os::raw::c_int = 11;
pub const BROTLI_DEFAULT_WINDOW: ::std::os::raw::c_int = 22;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "\u{1}__security_cookie"]
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
/// Allocating function pointer type.
///
/// @param opaque custom memory manager handle provided by client
/// @param size requested memory region size; can not be @c 0
/// @returns @c 0 in the case of failure
/// @returns a valid pointer to a memory region of at least @p size bytes
///          long otherwise
pub type brotli_alloc_func = ::std::option::Option<
    unsafe extern "C" fn(
        opaque: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
/// Deallocating function pointer type.
///
/// This function @b SHOULD do nothing if @p address is @c 0.
///
/// @param opaque custom memory manager handle provided by client
/// @param address memory region pointer returned by ::brotli_alloc_func, or @c 0
pub type brotli_free_func = ::std::option::Option<
    unsafe extern "C" fn(opaque: *mut ::std::os::raw::c_void, address: *mut ::std::os::raw::c_void),
>;
/// Default compression mode.
///
/// In this mode compressor does not know anything in advance about the
/// properties of the input.
pub const BrotliEncoderMode_BROTLI_MODE_GENERIC: BrotliEncoderMode = 0;
/// Compression mode for UTF-8 formatted text input.
pub const BrotliEncoderMode_BROTLI_MODE_TEXT: BrotliEncoderMode = 1;
/// Compression mode used in WOFF 2.0.
pub const BrotliEncoderMode_BROTLI_MODE_FONT: BrotliEncoderMode = 2;
/// Options for ::BROTLI_PARAM_MODE parameter.
pub type BrotliEncoderMode = i32;
/// Process input.
///
/// Encoder may postpone producing output, until it has processed enough input.
pub const BrotliEncoderOperation_BROTLI_OPERATION_PROCESS: BrotliEncoderOperation = 0;
/// Produce output for all processed input.
///
/// Actual flush is performed when input stream is depleted and there is enough
/// space in output stream. This means that client should repeat
/// ::BROTLI_OPERATION_FLUSH operation until @p available_in becomes @c 0, and
/// ::BrotliEncoderHasMoreOutput returns ::BROTLI_FALSE. If output is acquired
/// via ::BrotliEncoderTakeOutput, then operation should be repeated after
/// output buffer is drained.
///
/// @warning Until flush is complete, client @b SHOULD @b NOT swap,
///          reduce or extend input stream.
///
/// When flush is complete, output data will be sufficient for decoder to
/// reproduce all the given input.
pub const BrotliEncoderOperation_BROTLI_OPERATION_FLUSH: BrotliEncoderOperation = 1;
/// Finalize the stream.
///
/// Actual finalization is performed when input stream is depleted and there is
/// enough space in output stream. This means that client should repeat
/// ::BROTLI_OPERATION_FINISH operation until @p available_in becomes @c 0, and
/// ::BrotliEncoderHasMoreOutput returns ::BROTLI_FALSE. If output is acquired
/// via ::BrotliEncoderTakeOutput, then operation should be repeated after
/// output buffer is drained.
///
/// @warning Until finalization is complete, client @b SHOULD @b NOT swap,
///          reduce or extend input stream.
///
/// Helper function ::BrotliEncoderIsFinished checks if stream is finalized and
/// output fully dumped.
///
/// Adding more input data to finalized stream is impossible.
pub const BrotliEncoderOperation_BROTLI_OPERATION_FINISH: BrotliEncoderOperation = 2;
/// Emit metadata block to stream.
///
/// Metadata is opaque to Brotli: neither encoder, nor decoder processes this
/// data or relies on it. It may be used to pass some extra information from
/// encoder client to decoder client without interfering with main data stream.
///
/// @note Encoder may emit empty metadata blocks internally, to pad encoded
///       stream to byte boundary.
///
/// @warning Until emitting metadata is complete client @b SHOULD @b NOT swap,
///          reduce or extend input stream.
///
/// @warning The whole content of input buffer is considered to be the content
///          of metadata block. Do @b NOT @e append metadata to input stream,
///          before it is depleted with other operations.
///
/// Stream is soft-flushed before metadata block is emitted. Metadata block
/// @b MUST be no longer than than 16MiB.
pub const BrotliEncoderOperation_BROTLI_OPERATION_EMIT_METADATA: BrotliEncoderOperation = 3;
/// Operations that can be performed by streaming encoder.
pub type BrotliEncoderOperation = i32;
/// Tune encoder for specific input.
///
/// ::BrotliEncoderMode enumerates all available values.
pub const BrotliEncoderParameter_BROTLI_PARAM_MODE: BrotliEncoderParameter = 0;
/// The main compression speed-density lever.
///
/// The higher the quality, the slower the compression. Range is
/// from ::BROTLI_MIN_QUALITY to ::BROTLI_MAX_QUALITY.
pub const BrotliEncoderParameter_BROTLI_PARAM_QUALITY: BrotliEncoderParameter = 1;
/// Recommended sliding LZ77 window size.
///
/// Encoder may reduce this value, e.g. if input is much smaller than
/// window size.
///
/// Window size is `(1 << value) - 16`.
///
/// Range is from ::BROTLI_MIN_WINDOW_BITS to ::BROTLI_MAX_WINDOW_BITS.
pub const BrotliEncoderParameter_BROTLI_PARAM_LGWIN: BrotliEncoderParameter = 2;
/// Recommended input block size.
///
/// Encoder may reduce this value, e.g. if input is much smaller than input
/// block size.
///
/// Range is from ::BROTLI_MIN_INPUT_BLOCK_BITS to
/// ::BROTLI_MAX_INPUT_BLOCK_BITS.
///
/// @note Bigger input block size allows better compression, but consumes more
///       memory. \n The rough formula of memory used for temporary input
///       storage is `3 << lgBlock`.
pub const BrotliEncoderParameter_BROTLI_PARAM_LGBLOCK: BrotliEncoderParameter = 3;
/// Flag that affects usage of "literal context modeling" format feature.
///
/// This flag is a "decoding-speed vs compression ratio" trade-off.
pub const BrotliEncoderParameter_BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING:
    BrotliEncoderParameter = 4;
/// Estimated total input size for all ::BrotliEncoderCompressStream calls.
///
/// The default value is 0, which means that the total input size is unknown.
pub const BrotliEncoderParameter_BROTLI_PARAM_SIZE_HINT: BrotliEncoderParameter = 5;
/// Flag that determines if "Large Window Brotli" is used.
pub const BrotliEncoderParameter_BROTLI_PARAM_LARGE_WINDOW: BrotliEncoderParameter = 6;
/// Recommended number of postfix bits (NPOSTFIX).
///
/// Encoder may change this value.
///
/// Range is from 0 to ::BROTLI_MAX_NPOSTFIX.
pub const BrotliEncoderParameter_BROTLI_PARAM_NPOSTFIX: BrotliEncoderParameter = 7;
/// Recommended number of direct distance codes (NDIRECT).
///
/// Encoder may change this value.
///
/// Range is from 0 to (15 << NPOSTFIX) in steps of (1 << NPOSTFIX).
pub const BrotliEncoderParameter_BROTLI_PARAM_NDIRECT: BrotliEncoderParameter = 8;
/// Number of bytes of input stream already processed by a different instance.
///
/// @note It is important to configure all the encoder instances with same
///       parameters (except this one) in order to allow all the encoded parts
///       obey the same restrictions implied by header.
///
/// If offset is not 0, then stream header is omitted.
/// In any case output start is byte aligned, so for proper streams stitching
/// "predecessor" stream must be flushed.
///
/// Range is not artificially limited, but all the values greater or equal to
/// maximal window size have the same effect. Values greater than 2**30 are not
/// allowed.
pub const BrotliEncoderParameter_BROTLI_PARAM_STREAM_OFFSET: BrotliEncoderParameter = 9;
/// Options to be used with ::BrotliEncoderSetParameter.
pub type BrotliEncoderParameter = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrotliEncoderStateStruct {
    _unused: [u8; 0],
}
/// Opaque structure that holds encoder state.
///
/// Allocated and initialized with ::BrotliEncoderCreateInstance.
/// Cleaned up and deallocated with ::BrotliEncoderDestroyInstance.
pub type BrotliEncoderState = BrotliEncoderStateStruct;
extern "C" {
    /// Sets the specified parameter to the given encoder instance.
    ///
    /// @param state encoder instance
    /// @param param parameter to set
    /// @param value new parameter value
    /// @returns ::BROTLI_FALSE if parameter is unrecognized, or value is invalid
    /// @returns ::BROTLI_FALSE if value of parameter can not be changed at current
    ///          encoder state (e.g. when encoding is started, window size might be
    ///          already encoded and therefore it is impossible to change it)
    /// @returns ::BROTLI_TRUE if value is accepted
    /// @warning invalid values might be accepted in case they would not break
    ///          encoding process.
    pub fn BrotliEncoderSetParameter(
        state: *mut BrotliEncoderState,
        param: BrotliEncoderParameter,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Creates an instance of ::BrotliEncoderState and initializes it.
    ///
    /// @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
    /// case they are both zero, default memory allocators are used. @p opaque is
    /// passed to @p alloc_func and @p free_func when they are called. @p free_func
    /// has to return without doing anything when asked to free a NULL pointer.
    ///
    /// @param alloc_func custom memory allocation function
    /// @param free_func custom memory free function
    /// @param opaque custom memory manager handle
    /// @returns @c 0 if instance can not be allocated or initialized
    /// @returns pointer to initialized ::BrotliEncoderState otherwise
    pub fn BrotliEncoderCreateInstance(
        alloc_func: brotli_alloc_func,
        free_func: brotli_free_func,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut BrotliEncoderState;
}
extern "C" {
    /// Deinitializes and frees ::BrotliEncoderState instance.
    ///
    /// @param state decoder instance to be cleaned up and deallocated
    pub fn BrotliEncoderDestroyInstance(state: *mut BrotliEncoderState);
}
extern "C" {
    /// Calculates the output size bound for the given @p input_size.
    ///
    /// @warning Result is only valid if quality is at least @c 2 and, in
    ///          case ::BrotliEncoderCompressStream was used, no flushes
    ///          (::BROTLI_OPERATION_FLUSH) were performed.
    ///
    /// @param input_size size of projected input
    /// @returns @c 0 if result does not fit @c size_t
    pub fn BrotliEncoderMaxCompressedSize(input_size: usize) -> usize;
}
extern "C" {
    /// Performs one-shot memory-to-memory compression.
    ///
    /// Compresses the data in @p input_buffer into @p encoded_buffer, and sets
    /// @p *encoded_size to the compressed length.
    ///
    /// @note If ::BrotliEncoderMaxCompressedSize(@p input_size) returns non-zero
    ///       value, then output is guaranteed to be no longer than that.
    ///
    /// @note If @p lgwin is greater than ::BROTLI_MAX_WINDOW_BITS then resulting
    ///       stream might be incompatible with RFC 7932; to decode such streams,
    ///       decoder should be configured with
    ///       ::BROTLI_DECODER_PARAM_LARGE_WINDOW = @c 1
    ///
    /// @param quality quality parameter value, e.g. ::BROTLI_DEFAULT_QUALITY
    /// @param lgwin lgwin parameter value, e.g. ::BROTLI_DEFAULT_WINDOW
    /// @param mode mode parameter value, e.g. ::BROTLI_DEFAULT_MODE
    /// @param input_size size of @p input_buffer
    /// @param input_buffer input data buffer with at least @p input_size
    ///        addressable bytes
    /// @param[in, out] encoded_size @b in: size of @p encoded_buffer; \n
    ///                 @b out: length of compressed data written to
    ///                 @p encoded_buffer, or @c 0 if compression fails
    /// @param encoded_buffer compressed data destination buffer
    /// @returns ::BROTLI_FALSE in case of compression error
    /// @returns ::BROTLI_FALSE if output buffer is too small
    /// @returns ::BROTLI_TRUE otherwise
    pub fn BrotliEncoderCompress(
        quality: ::std::os::raw::c_int,
        lgwin: ::std::os::raw::c_int,
        mode: BrotliEncoderMode,
        input_size: usize,
        input_buffer: *const u8,
        encoded_size: *mut usize,
        encoded_buffer: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Compresses input stream to output stream.
    ///
    /// The values @p *available_in and @p *available_out must specify the number of
    /// bytes addressable at @p *next_in and @p *next_out respectively.
    /// When @p *available_out is @c 0, @p next_out is allowed to be @c NULL.
    ///
    /// After each call, @p *available_in will be decremented by the amount of input
    /// bytes consumed, and the @p *next_in pointer will be incremented by that
    /// amount. Similarly, @p *available_out will be decremented by the amount of
    /// output bytes written, and the @p *next_out pointer will be incremented by
    /// that amount.
    ///
    /// @p total_out, if it is not a null-pointer, will be set to the number
    /// of bytes compressed since the last @p state initialization.
    ///
    ///
    ///
    /// Internally workflow consists of 3 tasks:
    ///  -# (optionally) copy input data to internal buffer
    ///  -# actually compress data and (optionally) store it to internal buffer
    ///  -# (optionally) copy compressed bytes from internal buffer to output stream
    ///
    /// Whenever all 3 tasks can't move forward anymore, or error occurs, this
    /// method returns the control flow to caller.
    ///
    /// @p op is used to perform flush, finish the stream, or inject metadata block.
    /// See ::BrotliEncoderOperation for more information.
    ///
    /// Flushing the stream means forcing encoding of all input passed to encoder and
    /// completing the current output block, so it could be fully decoded by stream
    /// decoder. To perform flush set @p op to ::BROTLI_OPERATION_FLUSH.
    /// Under some circumstances (e.g. lack of output stream capacity) this operation
    /// would require several calls to ::BrotliEncoderCompressStream. The method must
    /// be called again until both input stream is depleted and encoder has no more
    /// output (see ::BrotliEncoderHasMoreOutput) after the method is called.
    ///
    /// Finishing the stream means encoding of all input passed to encoder and
    /// adding specific "final" marks, so stream decoder could determine that stream
    /// is complete. To perform finish set @p op to ::BROTLI_OPERATION_FINISH.
    /// Under some circumstances (e.g. lack of output stream capacity) this operation
    /// would require several calls to ::BrotliEncoderCompressStream. The method must
    /// be called again until both input stream is depleted and encoder has no more
    /// output (see ::BrotliEncoderHasMoreOutput) after the method is called.
    ///
    /// @warning When flushing and finishing, @p op should not change until operation
    ///          is complete; input stream should not be swapped, reduced or
    ///          extended as well.
    ///
    /// @param state encoder instance
    /// @param op requested operation
    /// @param[in, out] available_in @b in: amount of available input; \n
    ///                 @b out: amount of unused input
    /// @param[in, out] next_in pointer to the next input byte
    /// @param[in, out] available_out @b in: length of output buffer; \n
    ///                 @b out: remaining size of output buffer
    /// @param[in, out] next_out compressed output buffer cursor;
    ///                 can be @c NULL if @p available_out is @c 0
    /// @param[out] total_out number of bytes produced so far; can be @c NULL
    /// @returns ::BROTLI_FALSE if there was an error
    /// @returns ::BROTLI_TRUE otherwise
    pub fn BrotliEncoderCompressStream(
        state: *mut BrotliEncoderState,
        op: BrotliEncoderOperation,
        available_in: *mut usize,
        next_in: *mut *const u8,
        available_out: *mut usize,
        next_out: *mut *mut u8,
        total_out: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Checks if encoder instance reached the final state.
    ///
    /// @param state encoder instance
    /// @returns ::BROTLI_TRUE if encoder is in a state where it reached the end of
    ///          the input and produced all of the output
    /// @returns ::BROTLI_FALSE otherwise
    pub fn BrotliEncoderIsFinished(state: *mut BrotliEncoderState) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Checks if encoder has more output.
    ///
    /// @param state encoder instance
    /// @returns ::BROTLI_TRUE, if encoder has some unconsumed output
    /// @returns ::BROTLI_FALSE otherwise
    pub fn BrotliEncoderHasMoreOutput(state: *mut BrotliEncoderState) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Acquires pointer to internal output buffer.
    ///
    /// This method is used to make language bindings easier and more efficient:
    ///  -# push data to ::BrotliEncoderCompressStream,
    ///     until ::BrotliEncoderHasMoreOutput returns BROTL_TRUE
    ///  -# use ::BrotliEncoderTakeOutput to peek bytes and copy to language-specific
    ///     entity
    ///
    /// Also this could be useful if there is an output stream that is able to
    /// consume all the provided data (e.g. when data is saved to file system).
    ///
    /// @attention After every call to ::BrotliEncoderTakeOutput @p *size bytes of
    ///            output are considered consumed for all consecutive calls to the
    ///            instance methods; returned pointer becomes invalidated as well.
    ///
    /// @note Encoder output is not guaranteed to be contiguous. This means that
    ///       after the size-unrestricted call to ::BrotliEncoderTakeOutput,
    ///       immediate next call to ::BrotliEncoderTakeOutput may return more data.
    ///
    /// @param state encoder instance
    /// @param[in, out] size @b in: number of bytes caller is ready to take, @c 0 if
    ///                 any amount could be handled; \n
    ///                 @b out: amount of data pointed by returned pointer and
    ///                 considered consumed; \n
    ///                 out value is never greater than in value, unless it is @c 0
    /// @returns pointer to output data
    pub fn BrotliEncoderTakeOutput(state: *mut BrotliEncoderState, size: *mut usize) -> *const u8;
}
extern "C" {
    /// Gets an encoder library version.
    ///
    /// Look at BROTLI_VERSION for more information.
    pub fn BrotliEncoderVersion() -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrotliDecoderStateStruct {
    _unused: [u8; 0],
}
/// Opaque structure that holds decoder state.
///
/// Allocated and initialized with ::BrotliDecoderCreateInstance.
/// Cleaned up and deallocated with ::BrotliDecoderDestroyInstance.
pub type BrotliDecoderState = BrotliDecoderStateStruct;
/// Decoding error, e.g. corrupted input or memory allocation problem.
pub const BrotliDecoderResult_BROTLI_DECODER_RESULT_ERROR: BrotliDecoderResult = 0;
/// Decoding successfully completed.
pub const BrotliDecoderResult_BROTLI_DECODER_RESULT_SUCCESS: BrotliDecoderResult = 1;
/// Partially done; should be called again with more input.
pub const BrotliDecoderResult_BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: BrotliDecoderResult = 2;
/// Partially done; should be called again with more output.
pub const BrotliDecoderResult_BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: BrotliDecoderResult = 3;
/// Result type for ::BrotliDecoderDecompress and
/// ::BrotliDecoderDecompressStream functions.
pub type BrotliDecoderResult = i32;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_NO_ERROR: BrotliDecoderErrorCode = 0;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_SUCCESS: BrotliDecoderErrorCode = 1;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_NEEDS_MORE_INPUT: BrotliDecoderErrorCode = 2;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_NEEDS_MORE_OUTPUT: BrotliDecoderErrorCode = 3;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE:
    BrotliDecoderErrorCode = -1;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_RESERVED: BrotliDecoderErrorCode = -2;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE:
    BrotliDecoderErrorCode = -3;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET:
    BrotliDecoderErrorCode = -4;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME:
    BrotliDecoderErrorCode = -5;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: BrotliDecoderErrorCode = -6;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: BrotliDecoderErrorCode =
    -7;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT:
    BrotliDecoderErrorCode = -8;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1:
    BrotliDecoderErrorCode = -9;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2:
    BrotliDecoderErrorCode = -10;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: BrotliDecoderErrorCode =
    -11;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: BrotliDecoderErrorCode =
    -12;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: BrotliDecoderErrorCode =
    -13;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_PADDING_1: BrotliDecoderErrorCode =
    -14;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_PADDING_2: BrotliDecoderErrorCode =
    -15;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_FORMAT_DISTANCE: BrotliDecoderErrorCode = -16;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: BrotliDecoderErrorCode =
    -19;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: BrotliDecoderErrorCode =
    -20;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: BrotliDecoderErrorCode =
    -21;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: BrotliDecoderErrorCode =
    -22;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: BrotliDecoderErrorCode =
    -25;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: BrotliDecoderErrorCode =
    -26;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: BrotliDecoderErrorCode =
    -27;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES:
    BrotliDecoderErrorCode = -30;
pub const BrotliDecoderErrorCode_BROTLI_DECODER_ERROR_UNREACHABLE: BrotliDecoderErrorCode = -31;
/// Error code for detailed logging / production debugging.
///
/// See ::BrotliDecoderGetErrorCode and ::BROTLI_LAST_ERROR_CODE.
pub type BrotliDecoderErrorCode = i32;
/// Disable "canny" ring buffer allocation strategy.
///
/// Ring buffer is allocated according to window size, despite the real size of
/// the content.
pub const BrotliDecoderParameter_BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION:
    BrotliDecoderParameter = 0;
/// Flag that determines if "Large Window Brotli" is used.
pub const BrotliDecoderParameter_BROTLI_DECODER_PARAM_LARGE_WINDOW: BrotliDecoderParameter = 1;
/// Options to be used with ::BrotliDecoderSetParameter.
pub type BrotliDecoderParameter = i32;
extern "C" {
    /// Sets the specified parameter to the given decoder instance.
    ///
    /// @param state decoder instance
    /// @param param parameter to set
    /// @param value new parameter value
    /// @returns ::BROTLI_FALSE if parameter is unrecognized, or value is invalid
    /// @returns ::BROTLI_TRUE if value is accepted
    pub fn BrotliDecoderSetParameter(
        state: *mut BrotliDecoderState,
        param: BrotliDecoderParameter,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Creates an instance of ::BrotliDecoderState and initializes it.
    ///
    /// The instance can be used once for decoding and should then be destroyed with
    /// ::BrotliDecoderDestroyInstance, it cannot be reused for a new decoding
    /// session.
    ///
    /// @p alloc_func and @p free_func @b MUST be both zero or both non-zero. In the
    /// case they are both zero, default memory allocators are used. @p opaque is
    /// passed to @p alloc_func and @p free_func when they are called. @p free_func
    /// has to return without doing anything when asked to free a NULL pointer.
    ///
    /// @param alloc_func custom memory allocation function
    /// @param free_func custom memory free function
    /// @param opaque custom memory manager handle
    /// @returns @c 0 if instance can not be allocated or initialized
    /// @returns pointer to initialized ::BrotliDecoderState otherwise
    pub fn BrotliDecoderCreateInstance(
        alloc_func: brotli_alloc_func,
        free_func: brotli_free_func,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut BrotliDecoderState;
}
extern "C" {
    /// Deinitializes and frees ::BrotliDecoderState instance.
    ///
    /// @param state decoder instance to be cleaned up and deallocated
    pub fn BrotliDecoderDestroyInstance(state: *mut BrotliDecoderState);
}
extern "C" {
    /// Performs one-shot memory-to-memory decompression.
    ///
    /// Decompresses the data in @p encoded_buffer into @p decoded_buffer, and sets
    /// @p *decoded_size to the decompressed length.
    ///
    /// @param encoded_size size of @p encoded_buffer
    /// @param encoded_buffer compressed data buffer with at least @p encoded_size
    ///        addressable bytes
    /// @param[in, out] decoded_size @b in: size of @p decoded_buffer; \n
    ///                 @b out: length of decompressed data written to
    ///                 @p decoded_buffer
    /// @param decoded_buffer decompressed data destination buffer
    /// @returns ::BROTLI_DECODER_RESULT_ERROR if input is corrupted, memory
    ///          allocation failed, or @p decoded_buffer is not large enough;
    /// @returns ::BROTLI_DECODER_RESULT_SUCCESS otherwise
    pub fn BrotliDecoderDecompress(
        encoded_size: usize,
        encoded_buffer: *const u8,
        decoded_size: *mut usize,
        decoded_buffer: *mut u8,
    ) -> BrotliDecoderResult;
}
extern "C" {
    /// Decompresses the input stream to the output stream.
    ///
    /// The values @p *available_in and @p *available_out must specify the number of
    /// bytes addressable at @p *next_in and @p *next_out respectively.
    /// When @p *available_out is @c 0, @p next_out is allowed to be @c NULL.
    ///
    /// After each call, @p *available_in will be decremented by the amount of input
    /// bytes consumed, and the @p *next_in pointer will be incremented by that
    /// amount. Similarly, @p *available_out will be decremented by the amount of
    /// output bytes written, and the @p *next_out pointer will be incremented by
    /// that amount.
    ///
    /// @p total_out, if it is not a null-pointer, will be set to the number
    /// of bytes decompressed since the last @p state initialization.
    ///
    /// @note Input is never overconsumed, so @p next_in and @p available_in could be
    /// passed to the next consumer after decoding is complete.
    ///
    /// @param state decoder instance
    /// @param[in, out] available_in @b in: amount of available input; \n
    ///                 @b out: amount of unused input
    /// @param[in, out] next_in pointer to the next compressed byte
    /// @param[in, out] available_out @b in: length of output buffer; \n
    ///                 @b out: remaining size of output buffer
    /// @param[in, out] next_out output buffer cursor;
    ///                 can be @c NULL if @p available_out is @c 0
    /// @param[out] total_out number of bytes decompressed so far; can be @c NULL
    /// @returns ::BROTLI_DECODER_RESULT_ERROR if input is corrupted, memory
    ///          allocation failed, arguments were invalid, etc.;
    ///          use ::BrotliDecoderGetErrorCode to get detailed error code
    /// @returns ::BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT decoding is blocked until
    ///          more input data is provided
    /// @returns ::BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT decoding is blocked until
    ///          more output space is provided
    /// @returns ::BROTLI_DECODER_RESULT_SUCCESS decoding is finished, no more
    ///          input might be consumed and no more output will be produced
    pub fn BrotliDecoderDecompressStream(
        state: *mut BrotliDecoderState,
        available_in: *mut usize,
        next_in: *mut *const u8,
        available_out: *mut usize,
        next_out: *mut *mut u8,
        total_out: *mut usize,
    ) -> BrotliDecoderResult;
}
extern "C" {
    /// Checks if decoder has more output.
    ///
    /// @param state decoder instance
    /// @returns ::BROTLI_TRUE, if decoder has some unconsumed output
    /// @returns ::BROTLI_FALSE otherwise
    pub fn BrotliDecoderHasMoreOutput(state: *const BrotliDecoderState) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Acquires pointer to internal output buffer.
    ///
    /// This method is used to make language bindings easier and more efficient:
    ///  -# push data to ::BrotliDecoderDecompressStream,
    ///     until ::BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT is reported
    ///  -# use ::BrotliDecoderTakeOutput to peek bytes and copy to language-specific
    ///     entity
    ///
    /// Also this could be useful if there is an output stream that is able to
    /// consume all the provided data (e.g. when data is saved to file system).
    ///
    /// @attention After every call to ::BrotliDecoderTakeOutput @p *size bytes of
    ///            output are considered consumed for all consecutive calls to the
    ///            instance methods; returned pointer becomes invalidated as well.
    ///
    /// @note Decoder output is not guaranteed to be contiguous. This means that
    ///       after the size-unrestricted call to ::BrotliDecoderTakeOutput,
    ///       immediate next call to ::BrotliDecoderTakeOutput may return more data.
    ///
    /// @param state decoder instance
    /// @param[in, out] size @b in: number of bytes caller is ready to take, @c 0 if
    ///                 any amount could be handled; \n
    ///                 @b out: amount of data pointed by returned pointer and
    ///                 considered consumed; \n
    ///                 out value is never greater than in value, unless it is @c 0
    /// @returns pointer to output data
    pub fn BrotliDecoderTakeOutput(state: *mut BrotliDecoderState, size: *mut usize) -> *const u8;
}
extern "C" {
    /// Checks if instance has already consumed input.
    ///
    /// Instance that returns ::BROTLI_FALSE is considered "fresh" and could be
    /// reused.
    ///
    /// @param state decoder instance
    /// @returns ::BROTLI_TRUE if decoder has already used some input bytes
    /// @returns ::BROTLI_FALSE otherwise
    pub fn BrotliDecoderIsUsed(state: *const BrotliDecoderState) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Checks if decoder instance reached the final state.
    ///
    /// @param state decoder instance
    /// @returns ::BROTLI_TRUE if decoder is in a state where it reached the end of
    ///          the input and produced all of the output
    /// @returns ::BROTLI_FALSE otherwise
    pub fn BrotliDecoderIsFinished(state: *const BrotliDecoderState) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Acquires a detailed error code.
    ///
    /// Should be used only after ::BrotliDecoderDecompressStream returns
    /// ::BROTLI_DECODER_RESULT_ERROR.
    ///
    /// See also ::BrotliDecoderErrorString
    ///
    /// @param state decoder instance
    /// @returns last saved error code
    pub fn BrotliDecoderGetErrorCode(state: *const BrotliDecoderState) -> BrotliDecoderErrorCode;
}
extern "C" {
    /// Converts error code to a c-string.
    pub fn BrotliDecoderErrorString(c: BrotliDecoderErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Gets a decoder library version.
    ///
    /// Look at BROTLI_VERSION for more information.
    pub fn BrotliDecoderVersion() -> u32;
}
